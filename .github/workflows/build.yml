name: Build and Test

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        component: [backend, admin-ui, extension]

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: ${{ matrix.component }}/package.json

    - name: Install dependencies
      working-directory: ./${{ matrix.component }}
      run: npm ci

    - name: Build
      working-directory: ./${{ matrix.component }}
      run: |
        if [ "${{ matrix.component }}" = "extension" ]; then
          npm run compile
        else
          npm run build
        fi

    - name: Run tests (if available)
      working-directory: ./${{ matrix.component }}
      run: npm test || true

  prepare-release:
    runs-on: ubuntu-latest
    needs: build
    # Only generate release tag on pushes to main branch
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && success()
    outputs:
      release_tag: ${{ steps.tag.outputs.tag }}

    steps:
    - name: Generate release tag
      id: tag
      run: |
        TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
        RELEASE_TAG="release-${TIMESTAMP}"
        echo "tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
        echo "Release tag: ${RELEASE_TAG}"

  docker-build:
    runs-on: ubuntu-latest
    needs: [build, prepare-release]
    permissions:
      contents: read
      packages: write

    steps:
    - uses: actions/checkout@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata for Docker images
      id: meta
      run: |
        # Convert repository name to lowercase (required for Docker registry)
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "repo_lower=${REPO_LOWER}" >> $GITHUB_OUTPUT
        
        # Build tags for backend (comma-separated for docker/build-push-action)
        BACKEND_TAGS="ghcr.io/${REPO_LOWER}/backend:latest,ghcr.io/${REPO_LOWER}/backend:${{ github.sha }}"
        if [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ github.event_name }}" == "push" ]; then
          # Try to get release tag from prepare-release job if it ran
          if [ -n "${{ needs.prepare-release.outputs.release_tag }}" ]; then
            BACKEND_TAGS="${BACKEND_TAGS},ghcr.io/${REPO_LOWER}/backend:${{ needs.prepare-release.outputs.release_tag }}"
          fi
        fi
        echo "backend_tags=${BACKEND_TAGS}" >> $GITHUB_OUTPUT
        
        # Build tags for admin-ui
        ADMIN_UI_TAGS="ghcr.io/${REPO_LOWER}/admin-ui:latest,ghcr.io/${REPO_LOWER}/admin-ui:${{ github.sha }}"
        if [ "${{ github.ref }}" == "refs/heads/main" ] && [ "${{ github.event_name }}" == "push" ]; then
          # Try to get release tag from prepare-release job if it ran
          if [ -n "${{ needs.prepare-release.outputs.release_tag }}" ]; then
            ADMIN_UI_TAGS="${ADMIN_UI_TAGS},ghcr.io/${REPO_LOWER}/admin-ui:${{ needs.prepare-release.outputs.release_tag }}"
          fi
        fi
        echo "admin_ui_tags=${ADMIN_UI_TAGS}" >> $GITHUB_OUTPUT
        
        echo "Backend tags: ${BACKEND_TAGS}"
        echo "Admin UI tags: ${ADMIN_UI_TAGS}"

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.backend_tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push admin-ui image
      uses: docker/build-push-action@v5
      with:
        context: ./admin-ui
        file: ./admin-ui/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.admin_ui_tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  package-extension:
    runs-on: ubuntu-latest
    needs: build
    # Only package extension for releases
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && success()

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20'

    - name: Install dependencies
      working-directory: ./extension
      run: npm install

    - name: Build extension
      working-directory: ./extension
      run: npm run compile

    - name: Package extension
      working-directory: ./extension
      run: npx @vscode/vsce package --allow-missing-repository

    - name: Upload extension artifact
      uses: actions/upload-artifact@v4
      with:
        name: extension-vsix
        path: extension/*.vsix
        retention-days: 30

  release:
    runs-on: ubuntu-latest
    needs: [build, docker-build, package-extension, prepare-release]
    # Only create releases on pushes to main branch, not on PRs
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && success() && needs.prepare-release.result == 'success'
    permissions:
      contents: write
      packages: read

    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for tags

    - name: Download extension artifact
      uses: actions/download-artifact@v4
      with:
        name: extension-vsix
        path: ./release-artifacts/

    - name: Set release tag
      id: tag
      run: |
        RELEASE_TAG="${{ needs.prepare-release.outputs.release_tag }}"
        if [ -z "${RELEASE_TAG}" ]; then
          echo "Error: Release tag from prepare-release job is empty"
          echo "prepare-release result: ${{ needs.prepare-release.result }}"
          exit 1
        fi
        echo "tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
        echo "Using release tag: ${RELEASE_TAG}"

    - name: Get repository name (lowercase for Docker)
      id: repo
      run: |
        # Convert repository name to lowercase (required for Docker registry)
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "repo=${REPO_LOWER}" >> $GITHUB_OUTPUT
        echo "owner=${{ github.repository_owner }}" >> $GITHUB_OUTPUT

    - name: Create production docker-compose file
      run: |
        cat > release-artifacts/docker-compose.prod.yml << EOF
        # Production Docker Compose configuration
        # Uses images from GitHub Container Registry (ghcr.io)
        # Release: ${{ steps.tag.outputs.tag }}
        # 
        # To use this file:
        # 1. Log in to GitHub Container Registry:
        #    echo \$GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
        # 2. Run: docker compose -f docker-compose.prod.yml up -d
        #
        # Or set GITHUB_TOKEN environment variable and use:
        #    docker compose -f docker-compose.prod.yml --env-file .env.prod up -d

        services:
          postgres:
            image: postgres:15-alpine
            container_name: cursor-chat-sync-db
            environment:
              POSTGRES_DB: \${DB_NAME:-cursor_chat_sync}
              POSTGRES_USER: \${DB_USER:-postgres}
              POSTGRES_PASSWORD: \${DB_PASSWORD:-postgres}
            ports:
              - "5432:5432"
            volumes:
              - postgres_data:/var/lib/postgresql/data
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U \${DB_USER:-postgres}"]
              interval: 10s
              timeout: 5s
              retries: 5
            restart: unless-stopped

          backend:
            # Using release tag: ${{ steps.tag.outputs.tag }}
            # Also available as: latest
            image: ghcr.io/${{ steps.repo.outputs.repo }}/backend:${{ steps.tag.outputs.tag }}
            container_name: cursor-chat-sync-backend
            environment:
              PORT: 3000
              DB_HOST: postgres
              DB_PORT: 5432
              DB_NAME: \${DB_NAME:-cursor_chat_sync}
              DB_USER: \${DB_USER:-postgres}
              DB_PASSWORD: \${DB_PASSWORD:-postgres}
              JWT_SECRET: \${JWT_SECRET:-your-secret-key-change-in-production}
              JWT_EXPIRES_IN: \${JWT_EXPIRES_IN:-7d}
            ports:
              - "3000:3000"
            depends_on:
              postgres:
                condition: service_healthy
            restart: unless-stopped

          admin-ui:
            # Using release tag: ${{ steps.tag.outputs.tag }}
            # Also available as: latest
            image: ghcr.io/${{ steps.repo.outputs.repo }}/admin-ui:${{ steps.tag.outputs.tag }}
            container_name: cursor-chat-sync-admin-ui
            ports:
              - "80:80"
            depends_on:
              - backend
            environment:
              - VITE_API_URL=http://localhost:3000/api
            restart: unless-stopped

        volumes:
          postgres_data:
        EOF

    - name: Copy development docker-compose
      run: |
        cp docker-compose.yml release-artifacts/docker-compose.yml

    - name: Create Git tag
      run: |
        if [ -z "${{ steps.tag.outputs.tag }}" ]; then
          echo "Error: Release tag is empty. Cannot create git tag."
          exit 1
        fi
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "${{ steps.tag.outputs.tag }}" -m "Automated release: ${{ steps.tag.outputs.tag }}"
        git push origin "${{ steps.tag.outputs.tag }}"

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.tag.outputs.tag }}
        name: Release ${{ steps.tag.outputs.tag }}
        files: |
          release-artifacts/*.vsix
          release-artifacts/docker-compose.yml
          release-artifacts/docker-compose.prod.yml
        body: |
          ## Automated Release
          
          This is an automated release created on successful build.
          
          **Release Tag:** `${{ steps.tag.outputs.tag }}`
          **Commit:** ${{ github.sha }}
          **Branch:** ${{ github.ref_name }}
          **Workflow Run:** ${{ github.run_id }}
          
          ### Build Status
          ✅ All components built successfully
          ✅ Docker images built and pushed to GitHub Container Registry
          ✅ Extension packaged as .vsix
          
          ### Docker Images
          Images are available at GitHub Container Registry:
          - Backend: `ghcr.io/${{ steps.repo.outputs.repo }}/backend:${{ steps.tag.outputs.tag }}` (or `:latest`)
          - Admin UI: `ghcr.io/${{ steps.repo.outputs.repo }}/admin-ui:${{ steps.tag.outputs.tag }}` (or `:latest`)
          
          **To pull images, authenticate with GitHub Container Registry:**
          ```bash
          # Using GitHub Personal Access Token (PAT)
          echo \$GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
          
          # Create PAT at: https://github.com/settings/tokens
          # Required permission: read:packages
          ```
          
          ### Included Files
          - **Extension (.vsix)**: Install in Cursor/VS Code
          - **docker-compose.yml**: Development setup (builds from source)
          - **docker-compose.prod.yml**: Production setup (uses pre-built images from ghcr.io)
          
          ### Quick Start
          
          **Production Deployment:**
          ```bash
          # 1. Authenticate with GitHub Container Registry
          echo \$GITHUB_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
          
          # 2. Use production docker-compose
          docker compose -f docker-compose.prod.yml up -d
          ```
          
          **Development Setup:**
          ```bash
          # Use development docker-compose (builds from source)
          docker compose up -d
          ```
          
          ### Installation
          See [README.md](README.md) for detailed installation instructions.
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
